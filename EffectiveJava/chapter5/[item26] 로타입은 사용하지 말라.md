#26. 로 타입(raw type)은 사용하지 말라

 

## 용어 정리

 클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다. 예를 들어 List인터페이스는 원소타입을 나타내는 타입 매개변수 E를 받는다. 그래서 이 인터페이스의 완전한 이름은 List\<E>다. 제네릭 클래스와 제네릭 인터페이스를 통틀어 **제네릭 타입** 이라고 한다.

 각각의 제네릭 타입은 일련의 **매개변수화 타입(parameterized type)**을 정의한다. 먼저 클래스 혹은 인터페이스 이름이 나오고 이어서 꺽쇠괄호안에 실제타입 매개변수가 있다. List\<String>의 경우 원소의 타입이 String인 리스트를 뜻하는 **매개변수화 타입**이다. String은 타입 매개변수 E에 해당하는 **실제 타입 매개변수**이다.

 마지막 제네릭 타입을 하나 저으이하면 로타입(raw타입)도 함께 정의된다. 로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. **List\<E>의 로타입은 List**이다. 로 타입은 타입 선언에서 제네릭 타입이 모두 지워진 것처럼 동작하는데 **제네릭이 도래하기 전 코드와의 호환성 때문에 생긴것이다.**

 

## 로타입 예시

 자바 9에서도 동작하지만 좋은 예는 아니다.

~~~java
//stamp 인스턴스만 취급한다. -> 이렇게 적어놔도 컴파일러는 모른다.
private final Collection stamps = ...;

stamps.add(new Coin(...));
~~~

이 코드를 사용하면 Stamp 대신 Coin을 넣어도 오류가 없이 컴파일 되고 실행된다. 동전을 컬랙션에서 꺼내기 전에는 오류를 발견 못한다.



## 컴파일러와 로타입

 오류는 가능한 한 발생 즉시 이상적으로는 컴파일 할때 발견되는게 좋다. 로 타입에서는 오류가 발생하고 안참 뒤인 런타임에야 알아 챌수 있다. **제네릭을 활용하면 정보가 타입 선언 자체에 녹아들게 된다.**

~~~java
private final Collection<Stamp> stamps = ...;
~~~

 이렇게 할경우 stamps에는 stamp만 넣어야 하는 것을 컴파일러가 인지하게 된다. 컴파일 됬을때는 의도대로 동작할것임이 보장된다. 또한 컬랙션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.

 로타입을 쓰는것을 막아놓지는 않았지만 **절대로 써서는 안된다. 로타입을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.** 하지만 로타입을 이럼에도 불구하고 막지 않는 이유는 자바 옛 버전들과의 호환성 때문이다.



## 제네릭 유연하게 사용하기

 List같은 로 타입은 사용해서는 안되지만 List\<Object>처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다. 다를게 없어보이지만 List는 제네릭 타입에서 완전히 발을 뺀것이고, List\<Object>는 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다. **List\<Object>같은 매개변수화 타입을 사용할 떄와 달리 List같은 로타입을 사용하면 타입 안정성을 잃는다.**



 이쯤되면 원소의 타입을 몰라도 되는 로 타입을 쓰고 싶어질 수 있다. 다음 코드를 보자 다음 코드는 모르는 타입을 받을 수 있는 로타입 Set을 사용했다.

~~~java
static int numElementsInCommon(Set s1,Set s2){
	int result = 0;
  for(Object 01:s1){
    if(s2.contains(01)){
      result++;
    }
  }
  return result;
}
~~~

 로 타입을 사용하는건 안전하지 않다. 이럴때는 비한정 와일드카드 타입을 대신 사용하는게 좋다. 물음표를 사용하면 된다. 예컨대 제네릭 타입인 Set\<E>의 비 한정적 와일드 카드 타입은 Set\<?>이다. 어떤 타입이든 담을 수 있는 Set다. 하지만 Set<?\>와 Set의 차이는 무엇일까? 특징을 간단히 말하자면 **Set은 어떠한 타입도 넣을 수 있지만 Set\<?\>에는 어떤 원소도 넣을 수 없다.** ( Set<? extends String>의 경우에는 String이나 String하위 클래스만 가능하다는 뜻이다. -> 스트링은 하위 클래스가 없으므로 String은 String만 가능하다.)



## 예 외

로타입을 쓰면안되는 데 써야하는 경우가 몇가지 있다.

1. class리터럴에는 로 타입으로 써야한다. 자바 명세는 class리터럴에 매개변수화 타입을 사용하지 못하게 했다.(배열과 기본타입은 허용한다.)
   * ex) List.class, String[].class, int.class는 허용하고 List\<String\>.class나 List<?>.class는 허용하지 않는다.
2. instanceof연산자와 관련잇다. 런타임에는 제네릭 타입 정보가 지워지므로 instanceof연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다. 게다가 instanceof는 로타입이나 비한정적 와일드 카드타입이나 똑같이 작동한다.