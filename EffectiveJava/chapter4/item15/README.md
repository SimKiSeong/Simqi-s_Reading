# 15. 클래스와 멤버의 접근 권한을 최소화 하라



어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부데이터와 내부 구현정보를 얼마나 잘 숨겼냐다. 잘 설계된 컴포넌트는 구현과 API를 깔끔하게 분리한다. 정보은닉, 캡슐화라고 하는 이 개념은 소프트웨어 설계의 근간이 되는 원리다.



---

## 정보 은닉의 장점

* 시스템 개발 속도를 높인다. -> 컴포넌트를 병렬로 개발 할 수 있기 때문이다.
* 관리비용이 낮아진다. -> 각 컴포넌트를 더 빨리 파악하여 디버깅 할 수 있으며, 컴포넌트로 교체하는 부담도 적기 때문이다.
* 성능최적화에 도움을 준다. -> 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한다음 해당 컴포넌트만 최적화가 가능하기 때문이다.
* 재사용성이 높다. -> 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 찬선 환경에서도 유용하게 쓰일 가능성이 높다.
* 큰 시스템을 제작하는 난이도를 낮춰준다. -> 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.



---

## 접근 제한자를 재대로 활용 할 것



정보은닉의 핵심은 접근 제한자를 제대로 활용하는 것이다. 기본원칙은 **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.**



### 톱 클래스 (가장 바깥에 있는 클래스)

 톱클래스의 경우 package-private와 public 둘중에 하나를 취할 수 있다. 톱레벨 클래스나 인터페이스를 public으로 선언하면 공개 API가 되며 package-private로 선언하면 해당 패키지 안에서만 이용할 수 있다. 패키지 외부에서 쓸일이 없다면 package-private로 선언하면 API가 아닌 내부구현이 되어 **언제든지 수정할 수 있다.** 반면, API가 될경우 하위 호환을 위해 영원히 관리 해줘야만 한다.

 한 클래스에서만 package-private를 사용할 경우 private static으로 중첩시켜보자. 이럴경우 바깥 클래스 하나에서만 접근할 수 있다.

 ***package-private는 내부구현에 속하며, public은 package의 API이다.***



### 맴 버

 맴버의 경우 4가지 수준을 줄 수 있다. 

|                 | 해당클래스 안에서 | 같은 패키지 에서 | 상속받은 클래스에서 | import한 클래스에서 |
| :-------------: | :---------------: | :--------------: | :-----------------: | :-----------------: |
|     public      |         0         |        0         |          0          |          0          |
|    protected    |         0         |        0         |          0          |          X          |
| package-private |         0         |        0         |          X          |          X          |
|     private     |         0         |        X         |          X          |          X          |

 

* 공개 API를 세심히 설계한 후 private로 만들고 같은 패키지의 다른 클래스가 접근해야 하는 맴버에 한하여 package-private로 풀어준다. (너무 많이 풀어주게 된다면 컴포넌트를 분리해야 하는지 다시 검토해 봐야 한다.)
* private와 package-private는 모두 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다. (단, Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수 있다.)
* package-priavte를 protected로 바꾸게 되면 접근할 수 있는 대상의 범위가 넓어지며 공개 API가 되므로 protected는 적을수록 좋다.

접근을 좁히면 좁힐수록 좋은데 방해하는 제약이 하나 있다. 상위클래스의 메서드를 재정의 할때는 그 접근 수준을 상위 클래스보다 좁게 설정 할 수 없는데 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야하는 리스코프 치환 원칙 때문이다. (어길시 컴파일 오류 발생)



### 테스트와 접근 제한자

 테스트를 위해 접근제한자는 일정 수준까지는 넓혀도 된다. 단, 테스트만을 위하여 클래스, 인터페이스, 맴버를 공개 API로 만들면 안된다. 



### Public클래스의 인스턴스 필드

 public클래스의 인스턴스 필드는 되도록 public이 아니어야 하는데, 가변이나 final이 아닌 것을 public으로 선언하면 값을 제한할 힘이 없어지기 때문이다. 또한 필드가 수정될때 락같은 작업을 할 수 없으므로 스레드에 안전하지 않다. 심지어 final이면서 불변객체를 참조하더라도 public필드를 없애는 방식으로 리팩토링 할 수 없다.

 정적필드에서도 문제는 마찬가지지만 **예외**가 하나 있다. 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소로써 상수라면 public static final 필드로 공개해도 좋다. 단 반드시 기본타입이나 불변 객체를 참조해야 한다.



### 길이가 0이 아닌 배열

 길이가 0이 아닌 배열은 모두 변경 가능 하니 주의해야한다. public static final 배열 필드나 이 필드를 반환하는 접근자 매서드를 제공해서는 안된다. 해결방법은 다음과 같다. (클라이언트가 필요한 방식으로 구현하여 사용하자)

1. public 배열을 private로 만들고 public 불변 리스트 추가

~~~java
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = 
  Collections.unmodifiableList(Arrays.asList(PRIAVTE_VALUES));
~~~



2. 배열을 private로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법

~~~java
private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values(){
  return PRIVATE_VALUES.clone();
}
~~~







